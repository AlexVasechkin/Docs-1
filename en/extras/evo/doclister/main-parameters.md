---
title: "Main parameters"
_old_id: "1747"
_old_uri: "evo/doclister/main-parameters"
---

### General parameters

 <table><tbody><tr><th> Parameter </th> <th> Description </th> <th> Values </th> <th> Default </th> </tr><tr><td> **controller** </td> <td> Sets class for selection of data.   
 Base classes are located in folder DocLister/core/controller </td> <td> <dl><dt>site\_content</dt> <dd>to work with a Shopkeeper catalogue</dd> <dt>shopkeeper</dt> <dd>to work with a Shopkeeper catalogue</dd> <dt>onetable</dt> <dd>to work with a custom table</dd> <dt>site\_content\_tags</dt> <dd>output MODX documents filtered by tags, in conjunction with the TagSaver plugin</dd> </dl></td> <td> site\_content </td> </tr><tr><td> **idType** </td> <td> Type of document selection. The list of documents inserted into the query will be selected from the parameter with a name matching this parameter.   
 To avoid confusion it is recommended to always define this parameter explicitly. This is particularly important when the parameters **parents** and **documents** are used simultaneously. </td> <td> parents, documents </td> <td> parents </td> </tr><tr><td> **parents** </td> <td> Document selection based on a list of parent documents </td> <td> comma-separated list of parent document ids </td> <td> id of the page where the snippet is located </td> </tr><tr><td> **documents** </td> <td> Custom selection of documents.   
 If the **parents** parameter is used, the documents listed in this parameter will simply be mixed in with the results and subjected to subsequent selection rules (filtering, sorting). </td> <td> comma-separated list of document ids </td> <td> </td> </tr><tr><td> **ignoreEmpty** </td> <td> Allows selection of all records from a table if the **documents** parameter is not given. In this case, the **idType** parameter should be **documents**. </td> <td> 1, 0 </td> <td> 0 </td> </tr><tr><td> **display** </td> <td> Maximum number of documents to be selected </td> <td> integer >= 0 </td> <td> 0 </td> </tr><tr><td> **queryLimit** </td> <td> Maximum number of documents to be selected </td> <td> integer >= 0 </td> <td> 0 </td> </tr><tr><td> **depth** </td> <td> Selection depth using the **parents** parameter </td> <td> integer >= 0 </td> <td> 0 </td> </tr><tr><td> **offset** </td> <td> Number of documents to skip from the start of the list. Recalculated when using pagination. If it is always required to skip N documents, the **start** parameter must be used. </td> <td> integer >= 0 </td> <td> 0 </td> </tr><tr><td> **start** </td> <td> Number of documents to skip from the start of the selection. Combines with the value of **offset** which is set automatically during pagination. </td> <td> integer >= 0 </td> <td> 0 </td> </tr><tr><td> **total** </td> <td> Maximum number of documents displayed on one page of the selection </td> <td> integer >= 0 </td> <td> 0 </td> </tr><tr><td> **addWhereList** </td> <td> Additional conditions for document selection </td> <td> Any string that suitable for insertion into the WHERE clause of an SQL query </td> <td> empty </td> </tr><tr><td> **showParent** </td> <td> Exclusion of container documents </td> <td>  force exclusion of containers in the selection;  
**1** force inclusion of container in the selection;  
**-1** only exclude containers that are in the **parents** parameter. </td> <td> 0 </td> </tr><tr><td> **selectFields** </td> <td> Names of fields to be included in the selection </td> <td> </td> <td> empty </td> </tr><tr><td> **groupBy** </td> <td> Group results by a given field </td> <td> </td> <td> defined in the controller </td> </tr><tr><td> **urlScheme** </td> <td> URL generation scheme </td> <td> Schemes available in MODX Evolution (relative, http, https, full) </td> <td> relative </td> </tr><tr><td> **dateSource** </td> <td> Document field containing the date.   
 If a string other than **createdon** is given as the value, and the value of the field in the database is zero, the value in **createdon** is used regardless. For example: you use delayed publication for some documents and set up sorting by the pub\_date field. Thus with DocLister you will never end up in the situation where documents published without delayed publication will always be at the end of the list. </td> <td> Name of a field in a table. </td> <td> pub\_date </td> </tr><tr><td> **dateFormat** </td> <td> Date formatting rules for the PHP strftime() function.   
 The **dateSource** parameter is used as the source of the date. Also taken into account is the date offset in the server (see the system parameter **server\_offset\_time**). In this way, you can use a personalized substitution of the time depending on the user's time zone. </td> <td> </td> <td> %d.%b.%y %H:%M </td> </tr><tr><td> **summary** </td> <td> Rules for processing text to formulate the short description. Loads the **summary** extender. The site\_content controller contains an additional rule for the text being processed: the **content** field is sent for processing by default. But if the **introtext** field is not empty, then the text from this field is fed to the **summary** extender. The onetable controller behaves similarly. </td> <td> string formed according to the rules of the **summary** extender  
 action1:parameter1,action2:parameter2–ê:parameter2B,action3 </td> <td> </td> </tr><tr><td> **introField** </td> <td> Name of the field for the source of the short description of the text in the **contentField**. Only used when the **summary** extender is loaded. </td> <td> </td> <td> </td> </tr><tr><td> **contentField** </td> <td> Name of the field containing the basic text of the document. Only used when the **summary** extender is loaded. </td> <td> </td> <td> </td> </tr><tr><td> **e** </td> <td> Convert HTML special characters in fields into entities. Fields can be accessed in templates via placeholders with the prefix : \[+e.pagetitle+\], \[+e.longtitle+\]. </td> <td> Comma-separated list of field names </td> <td> </td> </tr><tr><td> **debug** </td> <td> Display SQL queries (1), complete information (2) on chunks used, data substituted etc. Information precedes output when positive, follows it when negative.   
</td> <td> -2, -1, 0, 1, 2   
</td> <td> 0 </td> </tr><tr><td> **customLang** </td> <td>Using a lexicon you can both redefine standard messages from the **/core/lang/\[(manager\_language)\]** folder and create new ones. When redefining, give the full name of the standard language key (e.g. `core.test` or `paginate.next`). To use the lexicon, put the tag `[%Lexicon key%]` in the template. </td> <td> Name of a PHP file in the **/core/lang/** folder containing associative array `$_lang` </td> <td> </td> </tr><tr><td> **jotcount** </td> <td> Includes the number of JotX comments in the selection, using the **jotcount** extender </td> <td> 1, 0 </td> <td> 0 </td></tr></tbody></table>### Selection parameters for custom tables (**onetable** controller)

 <table><tbody><tr><th> Parameter </th> <th> Description </th> <th> Values </th> <th> Default </th> </tr><tr><td> **table** </td> <td> Name of the table from which selection is to be made. If the table's PrimaryKey is not **id**, the name of this field must also be supplied in the **idField** parameter. </td> <td> any table name, omitting the MODX table prefix </td> <td> site\_content </td> </tr><tr><td> **idField** </td> <td> Name of the PrmaryKey field. Documents identified using the **documents** parameter will be selected according to this field. </td> <td> Any field available in the table named in the **table** parameter </td> <td> id </td> </tr><tr><td> **parentField** </td> <td> Name of the field where the **idField** values of the container documents are stored. Used when selecting documents from the **parents** parameter. </td> <td> Any field available in the table named in the **table** parameter </td> <td> parent </td></tr></tbody></table>### Selection using template variables

 <table><tbody><tr><th> Parameter </th> <th> Description </th> <th> Values </th> <th> Default </th> </tr><tr><td> **tvPrefix** </td> <td> Prefix for placeholders created from TV names </td> <td> </td> <td> tv </td> </tr><tr><td> **tvList** </td> <td> List of TVs to be included in the selection </td> <td> comma-separated list of TV names </td> <td> </td> </tr><tr><td> **renderTV** </td> <td> emplate variables to be processed for display according to the relevant widgets. TVs not included in the **tvList** parameter are ignored. </td> <td> **\*** or comma-separated list of TV names </td> <td> </td></tr></tbody></table>### Sorting

 <table><tbody><tr><th> Parameter </th> <th> Description </th> <th> Values </th> <th> Default </th> </tr><tr><td> **sortType** </td> <td> </td> <td>- none - automatic sorting according to MySQL rules (usually by primary key)
- doclist - output documents in the order provided in the **documents** parameter
- other - sort according to the criteria in the **orderBy**, **order** and **sortBy** parameters.
 
</td> <td> none </td> </tr><tr><td> **orderBy** </td> <td> Combined sort string (minimum being a combination of the **sortBy** and **sortDir** parameters, but with higher priority) </td> <td> Any string satisying the rules for construction of the ORDER BY clause in an SQL query. When sorting in the **site\_content** controller it is desirable to use the prefix **c.** for fields in the **site\_content** table. Names of template variables are given unmodified.  
 For random order use " **RAND()**" as the **orderBy** parameter. </td> <td> id DESC (or as defined in the controller) </td> </tr><tr><td> **sortBy** </td> <td> Sort criterion without sort direction </td> <td> Any string valid in an ORDER BY clause in an SQL query. Template variable names are given unmodified. </td> <td> Empty. Default value can be hard-coded in the controller. </td> </tr><tr><td> **order** </td> <td> Sort direction </td> <td> ASC, DESC. The value of this parameter can be redefined by the value of the **sortDir** parameter. </td> <td> DESC </td> </tr><tr><td> **sortDir** </td> <td> Alias for the **order** parameter, with higher priority. </td> <td> ASC, DESC </td> <td> DESC (or as defined in the controller) </td> </tr><tr><th colspan="4"> Sort using template variables </th> </tr><tr><td> **tvSortType** </td> <td> Type conversion rules for template variables during sorting </td> <td> listed separated by commas in the order the TV names are given in the **orderBy** parameter: - DECIMAL - numbers with two significant decimal places;
- UNSIGNED - unsigned integers;
- SIGNED - positive integers;
- BINARY - binary mode;
- DATETIME - date;
- TVDATETIME- converts string to a date according to the format used by template variables with the "Date" input type (only available with controllers based on \*site-content\*).
 
</td> <td> </td> </tr><tr><td> **tvSortWithDefault** </td> <td> System-specific features (template variables with values matching defaults values are not stored in the separate table) mean that sorting of records may not be correct when the default value is not an empty string. </td> <td> List of template variables that must be forced to the default value </td> <td> </td></tr></tbody></table>### Filtering

 <table><tbody><tr><th> Parameter </th> <th> Description </th> <th> Values </th> <th> Default </th> </tr><tr><td> **showNoPublish** </td> <td> Output deleted and unpublished resources (used only with controllers based on site\_content) </td> <td> 0, 1 </td> <td> 0 </td> </tr><tr><td> **filters** </td> <td> Rules for filtering documents </td> <td> Possible values - string following the rules set out in DocLister::getFilters(). See the "Filters" section for more details.   
 Example string:   
 OR(AND(filter:field:operator:value;filter2:field:operator:value);(...)) </td> <td> </td> </tr><tr><td> **filter\_delimiter** </td> <td> Filter divider for **containsOne** mode </td> <td> Any string </td> <td> </td></tr></tbody></table>### Selection using tags

 <table><tbody><tr><th> Parameter </th> <th> Description </th> <th> Values </th> <th> Default </th> </tr><tr><td> **tagsData** </td> <td> Source of tags.   
 For automatic insertion of tags from a **GET** variable, the name of this variable must be indicated, providing a value such as **get:tag** in this parameter. In this case the tags should be inserted into $\_GET\['tag'\].   
 If static selection is required, you can replace **get** with **static** and provide the tag's value following a colon, for example, **static:tag\_value**. </td> <td> String containing rules separated by colons </td> <td> </td></tr></tbody></table>